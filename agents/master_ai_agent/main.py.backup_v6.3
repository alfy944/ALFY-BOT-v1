"""
Master AI Agent v6.3 - DISCIPLINED TREND-AWARE TRADER
======================================================
Fix rispetto a v6.2:
- Modello decisione: gpt-5.1 (era gpt-4.1)
- Short edge più conservativo (min 20 trade, diff >10%)
- BTC regime fallback robusto (timeout + retry)
- Aggiunto flag per disabilitare short_edge in bull market
"""

import os
import json
import requests
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from openai import OpenAI

# ===========================================================
#          CONFIGURAZIONE & CLIENT
# ===========================================================

api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key if api_key else "sk-placeholder")

# Modelli
SCREENING_MODEL = os.getenv("SCREENING_MODEL", "gpt-4o-mini")
DECISION_MODEL = os.getenv("OPENAI_MODEL", "gpt-5.1")  # FIX: era gpt-4.1
MIN_CONFIDENCE = int(os.getenv("MIN_CONFIDENCE", "60"))
PRE_FILTER_THRESHOLD = int(os.getenv("PRE_FILTER_THRESHOLD", "15"))
MAX_ENTRY_DEVIATION_PCT = float(os.getenv("MAX_ENTRY_DEVIATION_PCT", "3.0"))

# Short edge settings (più conservativi)
SHORT_EDGE_MIN_TRADES = int(os.getenv("SHORT_EDGE_MIN_TRADES", "20"))  # Min trade per lato
SHORT_EDGE_MIN_DIFF = float(os.getenv("SHORT_EDGE_MIN_DIFF", "10.0"))  # Min differenza WR%
SHORT_EDGE_ENABLED = os.getenv("SHORT_EDGE_ENABLED", "true").lower() == "true"  # Flag per disabilitare

DATA_DIR = "/app/data"
os.makedirs(DATA_DIR, exist_ok=True)
MEMORY_FILE = os.path.join(DATA_DIR, "learning_memory.json")
LATEST_DECISIONS_FILE = os.path.join(DATA_DIR, "latest_decisions.json")
BTC_TREND_CACHE_FILE = os.path.join(DATA_DIR, "btc_trend_cache.json")

POSITION_MANAGER_URL = "http://position-manager-agent:8000"
TECHNICAL_ANALYZER_URL = "http://technical-analyzer-agent:8000"

app = FastAPI(title="Master AI Trader v6.3 - Disciplined Trend-Aware")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

screening_stats = {
    "filtered_out": 0,
    "screened_out": 0,
    "analyzed": 0,
    "btc_blocked": 0,
    "validation_failed": 0,
    "btc_fetch_errors": 0
}


def log(msg: str, level: str = "i") -> None:
    icons = {
        "i": "[i]",
        "F": "[F]",
        "S": "[S]",
        "AI": "[AI]",
        "X": "[X]",
        "BTC": "[₿]",
        "V": "[V]"
    }
    timestamp = datetime.now().strftime("%H:%M:%S")
    icon = icons.get(level, "[i]")
    print(f"[{timestamp}] {icon} {msg}", flush=True)


# ===========================================================
#          MODELLI PYDANTIC
# ===========================================================

class AnalysisPayload(BaseModel):
    symbol: str
    # Accetta entrambi i formati (orchestrator usa nomi diversi)
    tech_data: Optional[Dict[str, Any]] = None
    fib_data: Optional[Dict[str, Any]] = None
    gann_data: Optional[Dict[str, Any]] = None
    sentiment_data: Optional[Dict[str, Any]] = None
    # Nomi usati dall'orchestrator
    technical: Optional[Dict[str, Any]] = None
    fibonacci: Optional[Dict[str, Any]] = None
    gann: Optional[Dict[str, Any]] = None
    sentiment: Optional[Dict[str, Any]] = None
    
    def get_tech(self): return self.tech_data or self.technical or {}
    def get_fib(self): return self.fib_data or self.fibonacci or {}
    def get_gann(self): return self.gann_data or self.gann or {}
    def get_sentiment(self): return self.sentiment_data or self.sentiment or {}


class TradeOutcome(BaseModel):
    symbol: str
    pnl: float
    close_price: float
    reason: str = "Closed by TP/SL"
    side: Optional[str] = None


class DecisionResponse(BaseModel):
    decision: str
    confidence_score: float
    logic_log: List[str]
    trade_setup: Optional[Dict[str, Any]] = None


# ===========================================================
#          BTC TREND MACRO FILTER (ROBUSTO)
# ===========================================================

def get_btc_regime() -> Dict[str, Any]:
    """
    Determina se BTC è in regime BULLISH o BEARISH.
    Con fallback robusto se technical-analyzer non risponde.
    """
    global screening_stats
    
    # Check cache
    try:
        if os.path.exists(BTC_TREND_CACHE_FILE):
            with open(BTC_TREND_CACHE_FILE, "r") as f:
                cache = json.load(f)
                cache_time = datetime.fromisoformat(cache.get("timestamp", "2000-01-01"))
                age_seconds = (datetime.now() - cache_time).total_seconds()
                if age_seconds < 900:  # 15 min
                    return cache
    except Exception:
        pass

    result = {
        "regime": "NEUTRAL",
        "h4_trend": "UNKNOWN",
        "h1_trend": "UNKNOWN",
        "h4_rsi": 50,
        "macd_trend": "UNKNOWN",
        "bullish_signals": 0,
        "bearish_signals": 0,
        "fetch_error": False,
        "timestamp": datetime.now().isoformat()
    }

    # Retry con timeout progressivo
    for attempt, timeout in enumerate([3, 5, 8], 1):
        try:
            resp = requests.post(
                f"{TECHNICAL_ANALYZER_URL}/analyze_multi_tf",
                json={"symbol": "BTCUSDT", "timeframes": ["60", "240"]},
                timeout=timeout
            )
            
            if resp.status_code != 200:
                log(f"BTC regime: HTTP {resp.status_code} (attempt {attempt}/3)", "X")
                continue
                
            data = resp.json()

            h4_data = data.get("data", {}).get("240", {}) or {}
            h1_data = data.get("data", {}).get("60", {}) or {}

            h4_trend = h4_data.get("trend", "NEUTRAL")
            h1_trend = h1_data.get("trend", "NEUTRAL")

            h4_rsi = h4_data.get("rsi", 50)
            if isinstance(h4_rsi, dict):
                h4_rsi = h4_rsi.get("value", 50)
            h4_rsi = float(h4_rsi) if h4_rsi else 50

            macd_data = h4_data.get("macd", {})
            macd_trend = macd_data.get("trend", "NEUTRAL") if isinstance(macd_data, dict) else "NEUTRAL"

            bullish_signals = 0
            bearish_signals = 0

            if h4_trend == "BULLISH":
                bullish_signals += 2
            elif h4_trend == "BEARISH":
                bearish_signals += 2

            if h1_trend == "BULLISH":
                bullish_signals += 1
            elif h1_trend == "BEARISH":
                bearish_signals += 1

            if h4_rsi > 55:
                bullish_signals += 1
            elif h4_rsi < 45:
                bearish_signals += 1

            if macd_trend == "BULLISH":
                bullish_signals += 1
            elif macd_trend == "BEARISH":
                bearish_signals += 1

            if bullish_signals >= 2 and bearish_signals <= 1:
                regime = "BULLISH"
            elif bearish_signals >= 2 and bullish_signals <= 1:
                regime = "BEARISH"
            else:
                regime = "NEUTRAL"

            result = {
                "regime": regime,
                "h4_trend": h4_trend,
                "h1_trend": h1_trend,
                "h4_rsi": h4_rsi,
                "macd_trend": macd_trend,
                "bullish_signals": bullish_signals,
                "bearish_signals": bearish_signals,
                "fetch_error": False,
                "timestamp": datetime.now().isoformat()
            }

            with open(BTC_TREND_CACHE_FILE, "w") as f:
                json.dump(result, f, indent=2)
            
            return result

        except requests.exceptions.Timeout:
            log(f"BTC regime: timeout after {timeout}s (attempt {attempt}/3)", "X")
        except requests.exceptions.ConnectionError:
            log(f"BTC regime: connection error (attempt {attempt}/3)", "X")
        except Exception as e:
            log(f"BTC regime: {type(e).__name__}: {e} (attempt {attempt}/3)", "X")

    # Tutti i tentativi falliti - usa NEUTRAL come fallback sicuro
    screening_stats["btc_fetch_errors"] += 1
    log("BTC regime: all attempts failed, using NEUTRAL fallback", "X")
    result["fetch_error"] = True
    result["regime"] = "NEUTRAL"
    
    return result


# ===========================================================
#          PRE-FILTER (PYTHON, GRATIS)
# ===========================================================

def pre_filter(technical: Dict[str, Any], symbol: str) -> Dict[str, Any]:
    score = 0
    reasons: List[str] = []

    timeframes = technical.get("data", {}) or technical.get("timeframes", {})

    for tf_name in ["15", "60", "240"]:
        tf_data = timeframes.get(tf_name, {}) or {}
        if not tf_data:
            continue

        rsi_value = 50.0
        if "rsi_detail" in tf_data:
            rsi_value = float(tf_data["rsi_detail"].get("value", 50.0))
        elif "rsi" in tf_data:
            rsi_raw = tf_data["rsi"]
            if isinstance(rsi_raw, dict):
                rsi_value = float(rsi_raw.get("value", 50.0))
            else:
                rsi_value = float(rsi_raw) if rsi_raw else 50.0

        if rsi_value >= 75 or rsi_value <= 25:
            score += 25
            reasons.append(f"RSI extreme {tf_name}: {rsi_value:.1f}")
        elif rsi_value >= 65 or rsi_value <= 35:
            score += 10
            reasons.append(f"RSI interesting {tf_name}: {rsi_value:.1f}")

        macd_data = tf_data.get("macd", {})
        if isinstance(macd_data, dict):
            macd_cross = macd_data.get("cross", "NONE")
            macd_trend = macd_data.get("trend", "NEUTRAL")

            if macd_cross in ["BULLISH_CROSS", "BEARISH_CROSS"]:
                score += 20
                reasons.append(f"MACD cross {tf_name}: {macd_cross}")
            elif macd_trend in ["BULLISH", "BEARISH"]:
                score += 5
                reasons.append(f"MACD trend {tf_name}: {macd_trend}")

        volume_ratio = float(tf_data.get("volume_ratio", 1.0) or 1.0)
        if volume_ratio >= 2.0:
            score += 15
            reasons.append(f"High volume {tf_name}: {volume_ratio:.1f}x")
        elif volume_ratio >= 1.5:
            score += 5

        trend = tf_data.get("trend", "NEUTRAL")
        trend_strength = tf_data.get("trend_strength", "MODERATE")
        if trend in ["BULLISH", "BEARISH"] and trend_strength == "STRONG":
            score += 10
            reasons.append(f"Strong trend {tf_name}: {trend}")

    return {
        "pass": score >= PRE_FILTER_THRESHOLD,
        "score": min(score, 100),
        "reasons": reasons[:3],
    }


# ===========================================================
#          MEMORIA E STATISTICHE
# ===========================================================

def load_memory() -> List[Dict[str, Any]]:
    if os.path.exists(MEMORY_FILE):
        try:
            with open(MEMORY_FILE, "r") as f:
                return json.load(f)
        except Exception:
            pass
    return []


def save_memory(data: List[Dict[str, Any]]) -> None:
    if len(data) > 2000:
        data = data[-2000:]
    try:
        with open(MEMORY_FILE, "w") as f:
            json.dump(data, f, indent=2)
    except Exception:
        pass


def compute_global_stats(history: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Calcola statistiche con short_edge più conservativo."""
    total_trades = len(history)
    wins = sum(1 for h in history if float(h.get("pnl", 0) or 0) > 0)
    losses = sum(1 for h in history if float(h.get("pnl", 0) or 0) < 0)
    total_pnl = sum(float(h.get("pnl", 0) or 0) for h in history)

    gross_profit = sum(float(h.get("pnl", 0) or 0) for h in history if float(h.get("pnl", 0) or 0) > 0)
    gross_loss = sum(float(h.get("pnl", 0) or 0) for h in history if float(h.get("pnl", 0) or 0) < 0)
    
    profit_factor = None
    if gross_loss < 0 and abs(gross_loss) > 0:
        profit_factor = gross_profit / abs(gross_loss)

    by_symbol: Dict[str, Dict[str, Any]] = {}
    for h in history:
        sym = h.get("symbol")
        if not sym:
            continue
        if sym not in by_symbol:
            by_symbol[sym] = {"trades": 0, "wins": 0, "pnl": 0.0}
        by_symbol[sym]["trades"] += 1
        pnl = float(h.get("pnl", 0) or 0)
        if pnl > 0:
            by_symbol[sym]["wins"] += 1
        by_symbol[sym]["pnl"] += pnl

    for sym, st in by_symbol.items():
        trades = st["trades"]
        wins_sym = st["wins"]
        pnl_sym = st["pnl"]
        win_rate = (wins_sym / trades) * 100 if trades > 0 else 0.0
        st["win_rate"] = round(win_rate, 1)

        if trades >= 8 and win_rate < 30 and pnl_sym < 0:
            st["category"] = "AVOID"
        elif pnl_sym < 0 and win_rate < 45:
            st["category"] = "CAUTION"
        elif win_rate >= 50 and pnl_sym >= 0:
            st["category"] = "FAVORABLE"
        else:
            st["category"] = "NEUTRAL"

    by_side: Dict[str, Dict[str, Any]] = {}
    for h in history:
        side = h.get("side")
        if not side:
            continue
        if side not in by_side:
            by_side[side] = {"trades": 0, "wins": 0, "pnl": 0.0}
        by_side[side]["trades"] += 1
        pnl = float(h.get("pnl", 0) or 0)
        if pnl > 0:
            by_side[side]["wins"] += 1
        by_side[side]["pnl"] += pnl

    for side, st in by_side.items():
        trades_side = st["trades"]
        st["win_rate"] = round((st["wins"] / trades_side) * 100, 1) if trades_side > 0 else 0.0

    # SHORT EDGE PIÙ CONSERVATIVO
    short_edge = False
    short_edge_reason = "disabled"
    
    if SHORT_EDGE_ENABLED:
        if "Sell" in by_side and "Buy" in by_side:
            sell_trades = by_side["Sell"]["trades"]
            buy_trades = by_side["Buy"]["trades"]
            sell_wr = by_side["Sell"]["win_rate"]
            buy_wr = by_side["Buy"]["win_rate"]
            
            # Richiede minimo trade per entrambi i lati E differenza significativa
            if sell_trades >= SHORT_EDGE_MIN_TRADES and buy_trades >= SHORT_EDGE_MIN_TRADES:
                wr_diff = sell_wr - buy_wr
                if wr_diff >= SHORT_EDGE_MIN_DIFF:
                    short_edge = True
                    short_edge_reason = f"Sell WR {sell_wr}% vs Buy WR {buy_wr}% (diff={wr_diff:.1f}%)"
                else:
                    short_edge_reason = f"diff {wr_diff:.1f}% < required {SHORT_EDGE_MIN_DIFF}%"
            else:
                short_edge_reason = f"insufficient trades (Sell:{sell_trades}, Buy:{buy_trades}, min:{SHORT_EDGE_MIN_TRADES})"
    
    global_win_rate = round((wins / total_trades) * 100, 1) if total_trades > 0 else 0.0

    return {
        "total_trades": total_trades,
        "wins": wins,
        "losses": losses,
        "total_pnl": round(total_pnl, 2),
        "win_rate": global_win_rate,
        "profit_factor": round(profit_factor, 2) if profit_factor else None,
        "by_symbol": by_symbol,
        "by_side": by_side,
        "short_edge": short_edge,
        "short_edge_reason": short_edge_reason,
    }


def save_latest_decision(symbol: str, decision_data: Dict[str, Any]) -> None:
    try:
        current_data: Dict[str, Any] = {}
        if os.path.exists(LATEST_DECISIONS_FILE):
            try:
                with open(LATEST_DECISIONS_FILE, "r") as f:
                    current_data = json.load(f)
            except Exception:
                pass
        decision_data["timestamp"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        current_data[symbol] = decision_data
        with open(LATEST_DECISIONS_FILE, "w") as f:
            json.dump(current_data, f, indent=2)
    except Exception as e:
        log(f"Error saving decision: {e}", "X")


def check_open_position(symbol: str) -> bool:
    try:
        resp = requests.get(f"{POSITION_MANAGER_URL}/get_open_positions", timeout=2)
        data = resp.json()
        open_list = data.get("open_positions", [])
        if open_list and isinstance(open_list[0], dict):
            return any(p.get("symbol") == symbol for p in open_list)
        return symbol in open_list
    except Exception:
        return False


# ===========================================================
#          SCREENING (GPT-4o-mini)
# ===========================================================

SCREENING_PROMPT = """Sei uno screener veloce per crypto trading.

DATI:
{context}

BTC REGIME: {btc_regime}
SYMBOL CATEGORY: {category}

REGOLE IMPORTANTI:
1. Se BTC_REGIME = "BEARISH" e la direzione sarebbe LONG → rispondi "SKIP" (mercato sfavorevole ai LONG)
2. Se SYMBOL_CATEGORY = "AVOID" → rispondi "SKIP" a meno che il setup sia ECCEZIONALE
3. Cerca segnali chiari: RSI estremo, MACD cross, volume alto, trend forte
4. Sii SELETTIVO: meglio saltare un'opportunità dubbia che entrare male

Rispondi SOLO con JSON:
{{
  "verdict": "INTERESSANTE" | "SKIP",
  "direction_hint": "LONG" | "SHORT" | "UNCLEAR",
  "confidence": 0-100,
  "key_observation": "motivo principale in 15 parole max"
}}
"""


def screening_call(symbol: str, tech_data: Dict[str, Any], btc_regime: str, category: str) -> Dict[str, Any]:
    context_mini = {
        "symbol": symbol,
        "m15": tech_data.get("data", {}).get("15", {}),
        "h1": tech_data.get("data", {}).get("60", {}),
    }

    prompt = SCREENING_PROMPT.format(
        context=json.dumps(context_mini, indent=2),
        btc_regime=btc_regime,
        category=category
    )

    try:
        response = client.chat.completions.create(
            model=SCREENING_MODEL,
            messages=[{"role": "user", "content": prompt}],
            max_tokens=300,
            temperature=0.3
        )

        text = response.choices[0].message.content.strip()
        
        if "```json" in text:
            text = text.split("```json")[1].split("```")[0]
        elif "```" in text:
            parts = text.split("```")
            if len(parts) >= 2:
                text = parts[1]
        
        text = text.strip()
        if text.startswith("json"):
            text = text[4:].strip()
            
        return json.loads(text)
    except Exception as e:
        log(f"Screening error: {e}", "X")
        return {"verdict": "SKIP", "direction_hint": "UNCLEAR", "confidence": 0, "key_observation": "Error"}


# ===========================================================
#          FULL ANALYSIS PROMPT (GPT-5.1)
# ===========================================================

FULL_ANALYSIS_PROMPT = """
Sei Master-AI-Trader v6.3, un trader crypto DISCIPLINATO e SELETTIVO.

=== REGOLE FONDAMENTALI ===

1. BTC REGIME (CRITICO):
   - Se btc_regime = "BEARISH": NON aprire LONG su NESSUNA altcoin. Solo SHORT o WAIT.
   - Se btc_regime = "BULLISH": LONG permessi se il setup è buono.
   - Se btc_regime = "NEUTRAL": Valuta caso per caso.

2. SYMBOL CATEGORY:
   - "AVOID": DEFAULT = WAIT. Trade solo se setup ECCEZIONALE con R:R >= 2.
   - "CAUTION": Richiedi R:R >= 1.5 e confluenza forte.
   - "FAVORABLE": Puoi essere più opportunistico.
   - "NEUTRAL": Comportamento normale.

3. SHORT EDGE (se presente):
   - Se short_edge = true: Gli SHORT hanno evidenza statistica di performare meglio.
   - A parità di setup, preferisci SHORT.
   - MA: se il mercato mostra segni di bull run (BTC BULLISH, RSI alto), ignora short_edge.

4. CONFERME (checklist mentale):
   - Trend H4 allineato?
   - Trend H1 allineato?
   - RSI supporta l'idea?
   - MACD supporta l'idea?
   - Volume conferma?
   - Livello Fibonacci significativo?
   - Livello Gann significativo?
   - Sentiment non contrario?

   0-2 conferme → WAIT
   3-4 conferme → Trade possibile se R:R buono
   5+ conferme → Setup solido

5. GEOMETRIA SL/TP (OBBLIGATORIO):
   - LONG: SL < Entry < TP
   - SHORT: TP < Entry < SL
   - Entry DEVE essere vicino al prezzo corrente (max 1-2% di differenza)
   - Mira a R:R minimo 1.3, ideale 1.5–2.0

6. DISCIPLINA:
   - NON forzare trade quando il mercato è confuso.
   - Meglio WAIT che entrare male.
   - Confidence sotto 65 → WAIT.

=== CONTEXT ===
{context}

=== OUTPUT ===
Rispondi SOLO con JSON valido:
{{
  "decision": "OPEN_LONG" | "OPEN_SHORT" | "WAIT",
  "confidence_score": 0-100,
  "confirmations": 0-8,
  "strategy": "TREND_FOLLOWING" | "MEAN_REVERSION" | "BREAKOUT" | "NONE",
  "reasoning": "spiegazione max 80 parole",
  "trade_setup": {{
    "entry": float,
    "stop_loss": float,
    "take_profit": float,
    "risk_reward": float
  }}
}}

Se decision = "WAIT", trade_setup può essere null.
"""


def full_analysis_call(symbol: str, context: Dict[str, Any]) -> Dict[str, Any]:
    prompt = FULL_ANALYSIS_PROMPT.format(context=json.dumps(context, indent=2))
    
    try:
        response = client.chat.completions.create(
            model=DECISION_MODEL,
            messages=[
                {"role": "system", "content": "Sei un trader crypto disciplinato. Rispondi SOLO con JSON valido."},
                {"role": "user", "content": prompt}
            ],
            max_completion_tokens=4000,
            temperature=0.3
        )
        
        finish_reason = response.choices[0].finish_reason
        if finish_reason == "length":
            log(f"Warning: Response truncated (finish_reason=length)", "X")
        
        text = response.choices[0].message.content.strip()
        
        if "```json" in text:
            text = text.split("```json")[1].split("```")[0]
        elif "```" in text:
            parts = text.split("```")
            if len(parts) >= 2:
                text = parts[1]
        
        text = text.strip()
        if text.startswith("json"):
            text = text[4:].strip()
            
        return json.loads(text)
    except json.JSONDecodeError as e:
        log(f"JSON parse error: {e}", "X")
        return {"decision": "WAIT", "confidence_score": 0, "reasoning": f"JSON Error: {e}", "trade_setup": None}
    except Exception as e:
        log(f"Full analysis error: {e}", "X")
        return {"decision": "WAIT", "confidence_score": 0, "reasoning": f"Error: {e}", "trade_setup": None}


# ===========================================================
#          RISK ENGINE: SIZE & LEVERAGE + VALIDAZIONE
# ===========================================================

def compute_risk_parameters(
    symbol_category: str,
    global_stats: Dict[str, Any],
    decision: str,
    strategy: str,
    btc_regime: str
) -> Dict[str, Any]:
    """
    Calcola size_pct e leverage dinamici.
    Short edge applicato solo se NON siamo in bull market.
    """
    category = symbol_category.upper()
    
    base_size_map = {
        "FAVORABLE": 0.12,
        "NEUTRAL": 0.10,
        "CAUTION": 0.08,
        "AVOID": 0.06
    }
    base_size = base_size_map.get(category, 0.10)

    pf = global_stats.get("profit_factor")
    win_rate = float(global_stats.get("win_rate", 0) or 0)

    if pf is not None:
        if pf < 0.8 or win_rate < 40:
            base_size *= 0.7
        elif pf > 1.3 and win_rate > 50:
            base_size *= 1.15

    # Short edge - NON applicare se BTC è BULLISH
    short_edge = global_stats.get("short_edge", False)
    if short_edge and btc_regime != "BULLISH":
        if decision == "OPEN_SHORT":
            base_size *= 1.1
        elif decision == "OPEN_LONG":
            base_size *= 0.85

    strategy_multipliers = {
        "MEAN_REVERSION": 0.7,
        "BREAKOUT": 0.85,
        "TREND_FOLLOWING": 1.0,
        "NONE": 0.8
    }
    base_size *= strategy_multipliers.get(strategy, 1.0)

    size_pct = max(0.03, min(0.15, base_size))

    lev_map = {
        "FAVORABLE": 5,
        "NEUTRAL": 4,
        "CAUTION": 3,
        "AVOID": 2
    }
    lev = lev_map.get(category, 4)

    if short_edge and decision == "OPEN_SHORT" and btc_regime != "BULLISH":
        lev += 1
    if pf is not None and pf < 0.8:
        lev -= 1
    if pf is not None and pf < 0.6:
        lev -= 1

    lev = max(2, min(6, lev))

    return {"size_pct": round(size_pct, 4), "leverage": int(lev)}


def validate_and_enrich_trade_setup(
    decision: str,
    strategy: str,
    trade_setup: Optional[Dict[str, Any]],
    symbol_category: str,
    global_stats: Dict[str, Any],
    current_price: float,
    btc_regime: str
) -> Tuple[bool, Optional[Dict[str, Any]], str]:
    if decision == "WAIT":
        return False, None, "Decision is WAIT"

    if not trade_setup:
        return False, None, "Missing trade_setup from AI"

    try:
        entry = float(trade_setup.get("entry", 0))
        sl = float(trade_setup.get("stop_loss", 0))
        tp = float(trade_setup.get("take_profit", 0))
    except (TypeError, ValueError) as e:
        return False, None, f"Invalid numerical values: {e}"

    if entry <= 0 or sl <= 0 or tp <= 0:
        return False, None, f"Non-positive price levels: entry={entry}, sl={sl}, tp={tp}"

    if current_price and current_price > 0:
        entry_diff_pct = abs(entry - current_price) / current_price * 100
        if entry_diff_pct > MAX_ENTRY_DEVIATION_PCT:
            return False, None, f"Entry {entry:.6f} too far from current price {current_price:.6f} ({entry_diff_pct:.1f}% > {MAX_ENTRY_DEVIATION_PCT}%)"

    is_long = decision == "OPEN_LONG" and sl < entry < tp
    is_short = decision == "OPEN_SHORT" and tp < entry < sl
    
    if not (is_long or is_short):
        return False, None, f"Invalid geometry: {decision}, SL={sl:.6f}, Entry={entry:.6f}, TP={tp:.6f}"

    risk = abs(entry - sl)
    reward = abs(tp - entry)
    
    if risk <= 0:
        return False, None, "Risk is zero or negative"
    
    rr = reward / risk

    category = symbol_category.upper()
    pf = global_stats.get("profit_factor")
    win_rate = float(global_stats.get("win_rate", 0) or 0)
    short_edge = global_stats.get("short_edge", False)

    min_rr_map = {
        "AVOID": 2.0,
        "CAUTION": 1.5,
        "FAVORABLE": 1.2,
        "NEUTRAL": 1.3
    }
    min_rr = min_rr_map.get(category, 1.3)

    if pf is not None:
        if pf < 0.6:
            min_rr += 0.3
        elif pf < 0.8 or win_rate < 40:
            min_rr += 0.2
        elif pf > 1.3 and win_rate > 50:
            min_rr -= 0.1

    # Short edge adjustment - NON in bull market
    if short_edge and btc_regime != "BULLISH":
        if decision == "OPEN_LONG":
            min_rr += 0.1
        elif decision == "OPEN_SHORT":
            min_rr -= 0.1

    min_rr = max(1.2, min(2.5, min_rr))

    if rr < min_rr:
        return False, None, f"R:R {rr:.2f} < required {min_rr:.2f} (category={category}, pf={pf})"

    risk_params = compute_risk_parameters(category, global_stats, decision, strategy, btc_regime)

    enriched = {
        "entry": round(entry, 8),
        "stop_loss": round(sl, 8),
        "take_profit": round(tp, 8),
        "risk_reward": round(rr, 2),
        "size_pct": risk_params["size_pct"],
        "leverage": risk_params["leverage"]
    }
    
    return True, enriched, ""


# ===========================================================
#          ENDPOINTS
# ===========================================================

@app.on_event("startup")
async def startup():
    log("=" * 50, "i")
    log("Master AI v6.3 DISCIPLINED TREND-AWARE TRADER", "i")
    log(f"  Screening: {SCREENING_MODEL} | Decision: {DECISION_MODEL}", "i")
    log(f"  Min Confidence: {MIN_CONFIDENCE}% | Pre-filter: {PRE_FILTER_THRESHOLD}", "i")
    log(f"  Max Entry Deviation: {MAX_ENTRY_DEVIATION_PCT}%", "i")
    log(f"  Short Edge: enabled={SHORT_EDGE_ENABLED}, min_trades={SHORT_EDGE_MIN_TRADES}, min_diff={SHORT_EDGE_MIN_DIFF}%", "i")
    log("=" * 50, "i")

    if os.path.exists(LATEST_DECISIONS_FILE):
        try:
            with open(LATEST_DECISIONS_FILE, "r") as f:
                data = json.load(f)
                log(f"Loaded {len(data)} previous decisions", "i")
        except Exception:
            pass


@app.get("/health")
async def health():
    return {"status": "ok", "version": "6.3"}


@app.post("/analyze", response_model=DecisionResponse)
async def analyze(p: AnalysisPayload):
    global screening_stats
    symbol = p.symbol

    log(f"Analyzing {symbol}...", "i")

    if check_open_position(symbol):
        return DecisionResponse(
            decision="WAIT",
            confidence_score=0.0,
            logic_log=["Position already open"],
            trade_setup=None
        )

    history = load_memory()
    global_stats = compute_global_stats(history)
    symbol_stats = global_stats["by_symbol"].get(symbol, {
        "trades": 0,
        "wins": 0,
        "win_rate": 0.0,
        "pnl": 0.0,
        "category": "NEUTRAL"
    })
    category = symbol_stats.get("category", "NEUTRAL")

    btc_regime = get_btc_regime()
    btc_status = btc_regime.get("regime", "NEUTRAL")
    fetch_error = btc_regime.get("fetch_error", False)
    
    if fetch_error:
        log(f"BTC Regime: {btc_status} (FALLBACK - fetch error)", "BTC")
    else:
        log(f"BTC Regime: {btc_status} (bull:{btc_regime.get('bullish_signals', 0)}, bear:{btc_regime.get('bearish_signals', 0)})", "BTC")

    filter_result = pre_filter(p.get_tech(), symbol)
    if not filter_result["pass"]:
        screening_stats["filtered_out"] += 1
        log(f"{symbol}: Pre-filter FAIL (score: {filter_result['score']})", "F")
        save_latest_decision(symbol, {
            "decision": "FILTERED_OUT",
            "phase": "PRE_FILTER",
            "filter_score": filter_result["score"],
            "model": "python"
        })
        return DecisionResponse(
            decision="WAIT",
            confidence_score=0.0,
            logic_log=[f"Pre-filter score {filter_result['score']} < {PRE_FILTER_THRESHOLD}"],
            trade_setup=None
        )

    reasons_str = ", ".join(filter_result["reasons"]) if filter_result["reasons"] else "general"
    log(f"{symbol}: Pre-filter PASS (score: {filter_result['score']}, {reasons_str})", "F")

    log(f"{symbol}: Screening ({SCREENING_MODEL})...", "S")
    screening_result = screening_call(symbol, p.get_tech(), btc_status, category)

    verdict = screening_result.get("verdict", "SKIP")
    direction_hint = screening_result.get("direction_hint", "UNCLEAR")
    screening_confidence = screening_result.get("confidence", 0)
    key_obs = screening_result.get("key_observation", "")

    if btc_status == "BEARISH" and direction_hint == "LONG":
        screening_stats["btc_blocked"] += 1
        log(f"{symbol}: BLOCKED - LONG not allowed when BTC is BEARISH", "BTC")
        save_latest_decision(symbol, {
            "decision": "BTC_BLOCKED",
            "phase": "SCREENING",
            "btc_regime": btc_status,
            "direction_hint": direction_hint,
            "model": SCREENING_MODEL
        })
        return DecisionResponse(
            decision="WAIT",
            confidence_score=0.0,
            logic_log=["LONG blocked: BTC in BEARISH regime"],
            trade_setup=None
        )

    if verdict != "INTERESSANTE":
        screening_stats["screened_out"] += 1
        log(f"{symbol}: SCREENED OUT - {key_obs}", "S")
        save_latest_decision(symbol, {
            "decision": "SCREENED_OUT",
            "phase": "SCREENING",
            "screening_verdict": verdict,
            "key_observation": key_obs,
            "filter_score": filter_result["score"],
            "model": SCREENING_MODEL
        })
        return DecisionResponse(
            decision="WAIT",
            confidence_score=float(screening_confidence),
            logic_log=[f"Screening: {key_obs}"],
            trade_setup=None
        )

    log(f"{symbol}: INTERESSANTE ({direction_hint}) - {key_obs}", "S")

    log(f"{symbol}: Full analysis ({DECISION_MODEL})...", "AI")
    screening_stats["analyzed"] += 1

    current_price = float(p.get_fib().get("current_price", 0) or 0)
    
    context = {
        "symbol": symbol,
        "price": current_price,
        "btc_regime": btc_status,
        "btc_details": btc_regime,
        "technical_indicators": {
            "m15": p.get_tech().get("data", {}).get("15"),
            "h1": p.get_tech().get("data", {}).get("60"),
            "h4": p.get_tech().get("data", {}).get("240"),
        },
        "key_levels": {
            "fibonacci": p.get_fib(),
            "gann": p.get_gann(),
        },
        "market_sentiment": p.get_sentiment(),
        "symbol_stats": symbol_stats,
        "global_stats": {
            "total_trades": global_stats["total_trades"],
            "win_rate": global_stats["win_rate"],
            "profit_factor": global_stats["profit_factor"],
            "short_edge": global_stats["short_edge"],
            "short_edge_reason": global_stats["short_edge_reason"],
            "by_side": global_stats["by_side"]
        },
        "screening_hint": direction_hint,
    }

    result = full_analysis_call(symbol, context)

    decision = result.get("decision", "WAIT")
    confidence = float(result.get("confidence_score", 0) or 0)
    confirmations = int(result.get("confirmations", 0) or 0)
    strategy = result.get("strategy", "NONE")
    reasoning = result.get("reasoning", "")
    trade_setup = result.get("trade_setup")

    if btc_status == "BEARISH" and decision == "OPEN_LONG":
        log(f"{symbol}: FINAL BLOCK - LONG rejected (BTC BEARISH)", "BTC")
        decision = "WAIT"
        confidence = 0.0
        reasoning = "LONG blocked by BTC BEARISH regime"
        trade_setup = None

    if decision != "WAIT" and confidence < MIN_CONFIDENCE:
        log(f"{symbol}: Confidence {confidence}% < {MIN_CONFIDENCE}% minimum → WAIT", "AI")
        decision = "WAIT"
        trade_setup = None

    enriched_setup = None
    validation_msg = ""
    if decision != "WAIT":
        ok, enriched_setup, validation_msg = validate_and_enrich_trade_setup(
            decision=decision,
            strategy=strategy,
            trade_setup=trade_setup,
            symbol_category=category,
            global_stats=global_stats,
            current_price=current_price,
            btc_regime=btc_status
        )
        if not ok:
            screening_stats["validation_failed"] += 1
            log(f"{symbol}: Validation FAILED - {validation_msg}", "V")
            decision = "WAIT"
            confidence = 0.0
            reasoning = f"Setup rejected: {validation_msg}"
            enriched_setup = None

    if enriched_setup:
        log(f"{symbol}: {decision} (conf:{confidence}%, {confirmations}/8, {strategy}, R:R={enriched_setup['risk_reward']}, size={enriched_setup['size_pct']}, lev={enriched_setup['leverage']})", "AI")
    else:
        log(f"{symbol}: {decision} (conf:{confidence}%, {confirmations}/8, {strategy})", "AI")

    save_latest_decision(symbol, {
        "decision": decision,
        "confidence_score": confidence,
        "confirmations": confirmations,
        "strategy": strategy,
        "reasoning": reasoning,
        "trade_setup": enriched_setup,
        "phase": "FULL_ANALYSIS",
        "screening_hint": direction_hint,
        "filter_score": filter_result["score"],
        "btc_regime": btc_status,
        "symbol_category": category,
        "validation_msg": validation_msg if validation_msg else None,
        "model": DECISION_MODEL
    })

    return DecisionResponse(
        decision=decision,
        confidence_score=confidence,
        logic_log=[reasoning],
        trade_setup=enriched_setup
    )


@app.post("/learn")
async def learn(outcome: TradeOutcome):
    history = load_memory()
    entry = {
        "date": datetime.now().strftime("%Y-%m-%d %H:%M"),
        "symbol": outcome.symbol,
        "pnl": outcome.pnl,
        "close_price": outcome.close_price,
        "reason": outcome.reason,
    }
    if outcome.side:
        entry["side"] = outcome.side
    history.append(entry)
    save_memory(history)
    log(f"Learned: {outcome.symbol} PnL={outcome.pnl:.2f} ({outcome.reason})", "i")
    return {"status": "ok"}


@app.get("/latest_decisions")
async def get_latest_decisions():
    if os.path.exists(LATEST_DECISIONS_FILE):
        try:
            with open(LATEST_DECISIONS_FILE, "r") as f:
                return json.load(f)
        except Exception:
            pass
    return {}


@app.get("/stats")
async def get_stats():
    return {
        "screening_stats": screening_stats,
        "btc_regime": get_btc_regime()
    }


@app.get("/debug_stats")
async def debug_stats():
    history = load_memory()
    global_stats = compute_global_stats(history)
    return {
        "global": {
            "total_trades": global_stats["total_trades"],
            "wins": global_stats["wins"],
            "losses": global_stats["losses"],
            "total_pnl": global_stats["total_pnl"],
            "win_rate": global_stats["win_rate"],
            "profit_factor": global_stats["profit_factor"],
            "short_edge": global_stats["short_edge"],
            "short_edge_reason": global_stats["short_edge_reason"],
        },
        "by_symbol": global_stats["by_symbol"],
        "by_side": global_stats["by_side"],
        "btc_regime": get_btc_regime(),
        "screening_stats": screening_stats
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
